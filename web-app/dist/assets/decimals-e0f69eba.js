import{dX as D,dY as N,dZ as k,d_ as j,d$ as E,e0 as V,e1 as F,e2 as A,e3 as R,e4 as W,e5 as H,e6 as Z,e7 as J,e8 as O,e9 as Y,ea as K,eb as X,ec as x,ed as G}from"./index-6231ecd3.js";const Q=new Map,tt=new Map;function et(t){const e=(i,o)=>({clear:()=>o.delete(i),get:()=>o.get(i),set:r=>o.set(i,r)}),s=e(t,Q),n=e(t,tt);return{clear:()=>{s.clear(),n.clear()},promise:s,response:n}}async function st(t,{cacheKey:e,cacheTime:s=Number.POSITIVE_INFINITY}){const n=et(e),i=n.response.get();if(i&&s>0&&new Date().getTime()-i.created.getTime()<s)return i.data;let o=n.promise.get();o||(o=t(),n.promise.set(o));try{const r=await o;return n.response.set({created:new Date,data:r}),r}finally{n.promise.clear()}}async function nt(t,e,s){var o,r,a,c,u,h,f,p,d,y,w;const n=await D(e)(t,{headers:{...(a=(r=(o=e.config)==null?void 0:o.rpc)==null?void 0:r.fetch)==null?void 0:a.headers,"Content-Type":"application/json"},body:N(s.requests),method:"POST",requestTimeoutMs:s.requestTimeoutMs??((h=(u=(c=e.config)==null?void 0:c.rpc)==null?void 0:u.fetch)==null?void 0:h.requestTimeoutMs),keepalive:(d=(p=(f=e.config)==null?void 0:f.rpc)==null?void 0:p.fetch)==null?void 0:d.keepalive});if(!n.ok)throw(y=n.body)==null||y.cancel(),new Error(`RPC request failed with status ${n.status} - ${n.statusText}`);if((w=n.headers.get("Content-Type"))!=null&&w.startsWith("application/json"))return await n.json();const i=await n.text();try{return JSON.parse(i)}catch(T){throw console.error("Error parsing response",T,i),T}}async function it(t,e,s){var o,r,a,c,u,h,f,p,d,y,w;const n=await D(e)(t,{headers:{...((a=(r=(o=e.config)==null?void 0:o.rpc)==null?void 0:r.fetch)==null?void 0:a.headers)||{},"Content-Type":"application/json"},body:N(s.request),method:"POST",requestTimeoutMs:s.requestTimeoutMs??((h=(u=(c=e.config)==null?void 0:c.rpc)==null?void 0:u.fetch)==null?void 0:h.requestTimeoutMs),keepalive:(d=(p=(f=e.config)==null?void 0:f.rpc)==null?void 0:p.fetch)==null?void 0:d.keepalive});if(!n.ok)throw(y=n.body)==null||y.cancel(),new Error(`RPC request failed with status ${n.status}`);if((w=n.headers.get("Content-Type"))!=null&&w.startsWith("application/json"))return await n.json();const i=await n.text();try{return JSON.parse(i)}catch(T){throw console.error("Error parsing response",T,i),T}}const $=new WeakMap;function ot(t){if($.has(t))return $.get(t);const e=new Map;return $.set(t,e),e}function rt(t){return`${t.method}:${JSON.stringify(t.params)}`}const at=100,ct=0;function ut(t){const e=ot(t.client),s=t.chain.id;if(e.has(s))return e.get(s);const n=(()=>{var f,p,d,y,w,T;const i=k({client:t.client,chain:t.chain}),o=((f=t.config)==null?void 0:f.maxBatchSize)??((d=(p=t.client.config)==null?void 0:p.rpc)==null?void 0:d.maxBatchSize)??at,r=((y=t.config)==null?void 0:y.batchTimeoutMs)??((T=(w=t.client.config)==null?void 0:w.rpc)==null?void 0:T.batchTimeoutMs)??ct,a=new Map;let c=[],u=null;function h(){var C;u&&(clearTimeout(u),u=null);const P=new Array(c.length),b=c.slice().map((g,l)=>(g.request.id=l,g.request.jsonrpc="2.0",P[l]=g.request,g));c=[],nt(i,t.client,{requests:P,requestTimeoutMs:(C=t.config)==null?void 0:C.requestTimeoutMs}).then(g=>{b.forEach((l,M)=>{const m=g[M];if(!m){l.reject(new Error("No response"));return}if(m instanceof Error){l.reject(m);return}if(typeof m=="string"){l.reject(new Error(m));return}if("error"in m)l.reject(m.error);else{if(m.method==="eth_subscription")throw new Error("Subscriptions not supported yet");l.resolve(m.result)}a.delete(l.requestKey)})}).catch(g=>{for(const l of b)l.reject(g),a.delete(l.requestKey)})}return o===1?async P=>{var C;P.id=1,P.jsonrpc="2.0";const b=await it(i,t.client,{request:P,requestTimeoutMs:(C=t.config)==null?void 0:C.requestTimeoutMs});if(!b)throw new Error("No response");if("error"in b)throw b.error;return b.result}:async P=>{const b=rt(P);if(a.has(b))return a.get(b);let C,g;const l=new Promise((M,m)=>{C=M,g=m});return a.set(b,l),c.push({request:P,resolve:C,reject:g,requestKey:b}),o>1?(u||(u=setTimeout(h,r)),c.length>=o&&h()):h(),l}})();return e.set(s,n),n}function ht(t){return Object.fromEntries(Object.entries(t).map(([e,s])=>[e,{balance:s.balance?j(s.balance):void 0,nonce:s.nonce?j(s.nonce):void 0,code:s.code,state:s.state,stateDiff:s.stateDiff}]))}async function dt(t,e){const{blockNumber:s,blockTag:n,...i}=e,r=(s?j(s):void 0)||n||"latest";return await t({method:"eth_call",params:e.stateOverrides?[i,r,ht(e.stateOverrides)]:[i,r]})}function L(t,{includeName:e=!1}={}){return t?t.map(s=>ft(s,{includeName:e})).join(e?", ":","):""}function ft(t,{includeName:e}){return t.type.startsWith("tuple")?`(${L(t.components,{includeName:e})})${t.type.slice(5)}`:t.type+(e&&t.name?` ${t.name}`:"")}class lt extends E{constructor({data:e,params:s,size:n}){super([`Data size of ${n} bytes is too small for given parameters.`].join(`
`),{metaMessages:[`Params: (${L(s,{includeName:!0})})`,`Data:   ${e} (${n} bytes)`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiDecodingDataSizeTooSmallError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=e,this.params=s,this.size=n}}class pt extends E{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.'),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiDecodingZeroDataError"})}}class yt extends E{constructor(e,{docsPath:s}){super([`Type "${e}" is not a valid decoding type.`,"Please provide a valid ABI type."].join(`
`),{docsPath:s}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiDecodingType"})}}function z(t,{dir:e="left"}={}){let s=typeof t=="string"?t.replace("0x",""):t,n=0;for(let i=0;i<s.length-1&&s[e==="left"?i:s.length-i-1].toString()==="0";i++)n++;return s=e==="left"?s.slice(n):s.slice(0,s.length-n),typeof t=="string"?(s.length===1&&e==="right"&&(s=`${s}0`),`0x${s.length%2===1?`0${s}`:s}`):s}function bt(t,e){const s=e?`${e}${t.toLowerCase()}`:t.substring(2).toLowerCase(),n=V(F(s),"bytes"),i=(e?s.substring(`${e}0x`.length):s).split("");for(let o=0;o<40;o+=2)n[o>>1]>>4>=8&&i[o]&&(i[o]=i[o].toUpperCase()),(n[o>>1]&15)>=8&&i[o+1]&&(i[o+1]=i[o+1].toUpperCase());return`0x${i.join("")}`}function q(t){const e=t.match(/^(.*)\[(\d+)?\]$/);return e?[e[2]?Number(e[2]):null,e[1]]:void 0}class S extends E{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NegativeOffsetError"})}}class gt extends E{constructor({length:e,position:s}){super(`Position \`${s}\` is out of bounds (\`0 < position < ${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PositionOutOfBoundsError"})}}class mt extends E{constructor({count:e,limit:s}){super(`Recursive read limit of \`${s}\` exceeded (recursive read count: \`${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"RecursiveReadLimitExceededError"})}}const wt={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:1/0,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new mt({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(t){if(t<0||t>this.bytes.length-1)throw new gt({length:this.bytes.length,position:t})},decrementPosition(t){if(t<0)throw new S({offset:t});const e=this.position-t;this.assertPosition(e),this.position=e},getReadCount(t){return this.positionReadCount.get(t||this.position)||0},incrementPosition(t){if(t<0)throw new S({offset:t});const e=this.position+t;this.assertPosition(e),this.position=e},inspectByte(t){const e=t??this.position;return this.assertPosition(e),this.bytes[e]},inspectBytes(t,e){const s=e??this.position;return this.assertPosition(s+t-1),this.bytes.subarray(s,s+t)},inspectUint8(t){const e=t??this.position;return this.assertPosition(e),this.bytes[e]},inspectUint16(t){const e=t??this.position;return this.assertPosition(e+1),this.dataView.getUint16(e)},inspectUint24(t){const e=t??this.position;return this.assertPosition(e+2),(this.dataView.getUint16(e)<<8)+this.dataView.getUint8(e+2)},inspectUint32(t){const e=t??this.position;return this.assertPosition(e+3),this.dataView.getUint32(e)},pushByte(t){this.assertPosition(this.position),this.bytes[this.position]=t,this.position++},pushBytes(t){this.assertPosition(this.position+t.length-1),this.bytes.set(t,this.position),this.position+=t.length},pushUint8(t){this.assertPosition(this.position),this.bytes[this.position]=t,this.position++},pushUint16(t){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,t),this.position+=2},pushUint24(t){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,t>>8),this.dataView.setUint8(this.position+2,t&255),this.position+=3},pushUint32(t){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,t),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const t=this.inspectByte();return this.position++,t},readBytes(t,e){this.assertReadLimit(),this._touch();const s=this.inspectBytes(t);return this.position+=e??t,s},readUint8(){this.assertReadLimit(),this._touch();const t=this.inspectUint8();return this.position+=1,t},readUint16(){this.assertReadLimit(),this._touch();const t=this.inspectUint16();return this.position+=2,t},readUint24(){this.assertReadLimit(),this._touch();const t=this.inspectUint24();return this.position+=3,t},readUint32(){this.assertReadLimit(),this._touch();const t=this.inspectUint32();return this.position+=4,t},get remaining(){return this.bytes.length-this.position},setPosition(t){const e=this.position;return this.assertPosition(t),this.position=t,()=>this.position=e},_touch(){if(this.recursiveReadLimit===1/0)return;const t=this.getReadCount();this.positionReadCount.set(this.position,t+1),t>0&&this.recursiveReadCount++}};function Pt(t,{recursiveReadLimit:e=8192}={}){const s=Object.create(wt);return s.bytes=t,s.dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),s.positionReadCount=new Map,s.recursiveReadLimit=e,s}function vt(t,e={}){typeof e.size<"u"&&A(t,{size:e.size});const s=R(t,e);return W(s,e)}function Tt(t,e={}){let s=t;if(typeof e.size<"u"&&(A(s,{size:e.size}),s=z(s)),s.length>1||s[0]>1)throw new H(s);return!!s[0]}function v(t,e={}){typeof e.size<"u"&&A(t,{size:e.size});const s=R(t,e);return Z(s,e)}function Ct(t,e={}){let s=t;return typeof e.size<"u"&&(A(s,{size:e.size}),s=z(s,{dir:"right"})),new TextDecoder().decode(s)}function Bt(t,e){const s=typeof e=="string"?J(e):e,n=Pt(s);if(O(s)===0&&t.length>0)throw new pt;if(O(e)&&O(e)<32)throw new lt({data:typeof e=="string"?e:R(e),params:t,size:O(e)});let i=0;const o=[];for(let r=0;r<t.length;++r){const a=t[r];n.setPosition(i);const[c,u]=B(n,a,{staticPosition:0});i+=u,o.push(c)}return o}function B(t,e,{staticPosition:s}){const n=q(e.type);if(n){const[i,o]=n;return Et(t,{...e,type:o},{length:i,staticPosition:s})}if(e.type==="tuple")return At(t,e,{staticPosition:s});if(e.type==="address")return Rt(t);if(e.type==="bool")return Ut(t);if(e.type.startsWith("bytes"))return Ot(t,e,{staticPosition:s});if(e.type.startsWith("uint")||e.type.startsWith("int"))return xt(t,e);if(e.type==="string")return Mt(t,{staticPosition:s});throw new yt(e.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const I=32,_=32;function Rt(t){const e=t.readBytes(32);return[bt(R(Y(e,-20))),32]}function Et(t,e,{length:s,staticPosition:n}){if(!s){const r=v(t.readBytes(_)),a=n+r,c=a+I;t.setPosition(a);const u=v(t.readBytes(I)),h=U(e);let f=0;const p=[];for(let d=0;d<u;++d){t.setPosition(c+(h?d*32:f));const[y,w]=B(t,e,{staticPosition:c});f+=w,p.push(y)}return t.setPosition(n+32),[p,32]}if(U(e)){const r=v(t.readBytes(_)),a=n+r,c=[];for(let u=0;u<s;++u){t.setPosition(a+u*32);const[h]=B(t,e,{staticPosition:a});c.push(h)}return t.setPosition(n+32),[c,32]}let i=0;const o=[];for(let r=0;r<s;++r){const[a,c]=B(t,e,{staticPosition:n+i});i+=c,o.push(a)}return[o,i]}function Ut(t){return[Tt(t.readBytes(32),{size:32}),32]}function Ot(t,e,{staticPosition:s}){const[n,i]=e.type.split("bytes");if(!i){const r=v(t.readBytes(32));t.setPosition(s+r);const a=v(t.readBytes(32));if(a===0)return t.setPosition(s+32),["0x",32];const c=t.readBytes(a);return t.setPosition(s+32),[R(c),32]}return[R(t.readBytes(parseInt(i),32)),32]}function xt(t,e){const s=e.type.startsWith("int"),n=parseInt(e.type.split("int")[1]||"256"),i=t.readBytes(32);return[n>48?vt(i,{signed:s}):v(i,{signed:s}),32]}function At(t,e,{staticPosition:s}){const n=e.components.length===0||e.components.some(({name:r})=>!r),i=n?[]:{};let o=0;if(U(e)){const r=v(t.readBytes(_)),a=s+r;for(let c=0;c<e.components.length;++c){const u=e.components[c];t.setPosition(a+o);const[h,f]=B(t,u,{staticPosition:a});o+=f,i[n?c:u==null?void 0:u.name]=h}return t.setPosition(s+32),[i,32]}for(let r=0;r<e.components.length;++r){const a=e.components[r],[c,u]=B(t,a,{staticPosition:s});i[n?r:a==null?void 0:a.name]=c,o+=u}return[i,o]}function Mt(t,{staticPosition:e}){const s=v(t.readBytes(32)),n=e+s;t.setPosition(n);const i=v(t.readBytes(32));if(i===0)return t.setPosition(e+32),["",32];const o=t.readBytes(i,32),r=Ct(z(o));return t.setPosition(e+32),[r,32]}function U(t){var n;const{type:e}=t;if(e==="string"||e==="bytes"||e.endsWith("[]"))return!0;if(e==="tuple")return(n=t.components)==null?void 0:n.some(U);const s=q(t.type);return!!(s&&U({...t,type:s[1]}))}async function $t(t){const{contract:e,method:s,params:n}=t,i=async()=>{var f,p;if(Array.isArray(s))return s;if(X(s))return x(s);if(typeof s=="function")return x(await s(e));if(typeof s=="string"&&s.startsWith("function ")){const d=G(s);if(d.type==="function")return x(d);throw new Error('"method" passed is not of type "function"')}if(e.abi&&((f=e.abi)==null?void 0:f.length)>0){const d=(p=e.abi)==null?void 0:p.find(y=>y.type==="function"&&y.name===s);if(d)return x(d)}throw new Error(`Could not resolve method "${s}".`)},[o,r]=await Promise.all([i(),typeof n=="function"?n():n]);let a;o[1].length===0?a=o[0]:a=o[0]+K(o[1],r).slice(2);const c=ut({chain:e.chain,client:e.client}),u=await dt(c,{data:a,to:e.address}),h=Bt(o[2],u);return Array.isArray(h)&&h.length===1?h[0]:h}const jt="0x313ce567",_t=[],zt=[{type:"uint8"}];async function St(t){return $t({contract:t.contract,method:[jt,_t,zt],params:[]})}async function Dt(t){return st(()=>St(t),{cacheKey:`${t.contract.chain.id}:${t.contract.address}:decimals`,cacheTime:Number.POSITIVE_INFINITY})}export{Dt as decimals};
