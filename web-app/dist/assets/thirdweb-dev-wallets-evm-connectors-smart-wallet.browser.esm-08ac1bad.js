import{a2 as k,a4 as B,dz as H,ce as O,dA as m,ac as I,B as l,dB as C,dC as D,aZ as G,dD as K,aV as W,dE as L,dF as U,dG as V,bt as $,_ as M,dH as z,av as N,dI as T,dJ as b,dK as S,dL as J,dM as j,a as F,a3 as R,dN as Y,dO as q,dP as Z,dQ as Q,bB as A,a$ as P,co as X,dn as tt,dy as et,dR as at,dS as st,dT as rt,dU as it}from"./index-5efc63cb.js";async function v(o){const t=await m(o);return Object.keys(t).map(e=>{let a=t[e];return(typeof a!="string"||!a.startsWith("0x"))&&(a=F(a)),[e,a]}).reduce((e,a)=>{let[s,i]=a;return{...e,[s]:i}},{})}async function nt(o,t,e){const a=await m(o),s={sender:a.sender,nonce:a.nonce,initCodeHash:A(a.initCode),callDataHash:A(a.callData),callGasLimit:a.callGasLimit,verificationGasLimit:a.verificationGasLimit,preVerificationGas:a.preVerificationGas,maxFeePerGas:a.maxFeePerGas,maxPriorityFeePerGas:a.maxPriorityFeePerGas,paymasterAndDataHash:A(a.paymasterAndData)},i={components:[{type:"address",name:"sender"},{type:"uint256",name:"nonce"},{type:"bytes32",name:"initCodeHash"},{type:"bytes32",name:"callDataHash"},{type:"uint256",name:"callGasLimit"},{type:"uint256",name:"verificationGasLimit"},{type:"uint256",name:"preVerificationGas"},{type:"uint256",name:"maxFeePerGas"},{type:"uint256",name:"maxPriorityFeePerGas"},{type:"bytes32",name:"paymasterAndDataHash"}],name:"hashedUserOp",type:"tuple"},r=P.encode([i],[{...s}]),c=A(r),u=P.encode(["bytes32","address","uint256"],[c,t,e]);return A(u)}const ot=()=>{const o=BigInt(Math.floor(Math.random()*4294967296)),t=BigInt(Math.floor(Math.random()*4294967296)),e=BigInt(Math.floor(Math.random()*4294967296)),a=BigInt(Math.floor(Math.random()*4294967296)),s=BigInt(Math.floor(Math.random()*4294967296)),i=BigInt(Math.floor(Math.random()*4294967296));return o<<BigInt(160)|t<<BigInt(128)|e<<BigInt(96)|a<<BigInt(64)|s<<BigInt(32)|i},E=()=>{let o=ot().toString(16);return o.length%2!==0&&(o="0"+o),o="0x"+o,l.from(it([o,"0x0000000000000000"]))};class ct{}class dt{constructor(t,e,a,s,i){this.bundlerUrl=t,this.entryPointAddress=e,this.chainId=a;const r={};if(T(this.bundlerUrl)){const c=typeof globalThis<"u"&&"APP_BUNDLE_ID"in globalThis?globalThis.APP_BUNDLE_ID:void 0;i?r["x-secret-key"]=i:s&&(r["x-client-id"]=s,c&&(r["x-bundle-id"]=c)),typeof globalThis<"u"&&"TW_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_AUTH_TOKEN=="string"&&(r.authorization=`Bearer ${globalThis.TW_AUTH_TOKEN}`),typeof globalThis<"u"&&"TW_CLI_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_CLI_AUTH_TOKEN=="string"&&(r.authorization=`Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`,r["x-authorize-wallet"]="true"),b(r)}this.userOpJsonRpcProvider=new S({url:this.bundlerUrl,headers:r},{name:"Connected bundler network",chainId:a}),this.initializing=this.validateChainId()}async validateChainId(){const t=await this.userOpJsonRpcProvider.send("eth_chainId",[]),e=parseInt(t);if(e!==this.chainId)throw new Error(`bundler ${this.bundlerUrl} is on chainId ${e}, but provider is on chainId ${this.chainId}`)}async sendUserOpToBundler(t){await this.initializing;const e=await v(t),a=[e,this.entryPointAddress];return await this.printUserOperation("eth_sendUserOperation",a),await this.userOpJsonRpcProvider.send("eth_sendUserOperation",[e,this.entryPointAddress])}async estimateUserOpGas(t){await this.initializing;const e=await v(t),a=[e,this.entryPointAddress];await this.printUserOperation("eth_estimateUserOperationGas",a);const s=await this.userOpJsonRpcProvider.send("eth_estimateUserOperationGas",[e,this.entryPointAddress]);return{preVerificationGas:l.from(s.preVerificationGas),verificationGas:l.from(s.verificationGas),verificationGasLimit:l.from(s.verificationGasLimit),callGasLimit:l.from(s.callGasLimit).add(J)}}async getUserOperationGasPrice(){return await this.initializing,await this.userOpJsonRpcProvider.send("thirdweb_getUserOperationGasPrice",[])}async getUserOperationReceipt(t){return await this.initializing,await this.userOpJsonRpcProvider.send("eth_getUserOperationReceipt",[t])}async printUserOperation(t,e){}}class ht extends ct{constructor(t,e,a,s){super(),this.paymasterUrl=t,this.entryPoint=e,this.clientId=a,this.secretKey=s}async getPaymasterAndData(t){var i;const e={"Content-Type":"application/json"};if(T(this.paymasterUrl)){if(this.secretKey&&this.clientId)throw new Error("Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.");if(this.secretKey)e["x-secret-key"]=this.secretKey;else if(this.clientId){e["x-client-id"]=this.clientId;const r=typeof globalThis<"u"&&"APP_BUNDLE_ID"in globalThis?globalThis.APP_BUNDLE_ID:void 0;r&&(e["x-bundle-id"]=r)}typeof globalThis<"u"&&"TW_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_AUTH_TOKEN=="string"&&(e.authorization=`Bearer ${globalThis.TW_AUTH_TOKEN}`),typeof globalThis<"u"&&"TW_CLI_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_CLI_AUTH_TOKEN=="string"&&(e.authorization=`Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`,e["x-authorize-wallet"]="true"),b(e)}const a=await fetch(this.paymasterUrl,{method:"POST",headers:e,body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[await v(t),this.entryPoint]})}),s=await a.json();if(!a.ok){const r=s.error||a.statusText,c=s.code||"UNKNOWN";throw new Error(`Paymaster error: ${r}
Status: ${a.status}
Code: ${c}`)}if(s.result)return typeof s.result=="string"?{paymasterAndData:s.result}:s.result;{const r=((i=s.error)==null?void 0:i.message)||s.error||a.statusText||"unknown error";throw new Error(`Paymaster error from ${this.paymasterUrl}: ${r}`)}}}const lt=(o,t,e,a)=>new ht(o,t,e,a);class _{constructor(t,e,a,s,i,r,c){this.resolve=t,this.reject=e,this.entryPoint=a,this.sender=s,this.userOpHash=i,this.nonce=r,this.timeout=c,R(this,"resolved",!1),this.boundLisener=this.listenerCallback.bind(this)}start(){const t=this.entryPoint.filters.UserOperationEvent(this.userOpHash);setTimeout(async()=>{const e=await this.entryPoint.queryFilter(t,-10);e.length>0?this.listenerCallback(e[0]):this.entryPoint.once(t,this.boundLisener)},100)}stop(){this.entryPoint.off("UserOperationEvent",this.boundLisener)}async listenerCallback(){var r;for(var t=arguments.length,e=new Array(t),a=0;a<t;a++)e[a]=arguments[a];const s=arguments[arguments.length-1];if(!s.args){console.error("got event without args",s);return}if(s.args.userOpHash!==this.userOpHash){console.log(`== event with wrong userOpHash: sender/nonce: event.${s.args.sender}@${s.args.nonce.toString()}!= userOp.${this.sender}@${parseInt((r=this.nonce)==null?void 0:r.toString())}`);return}const i=await s.getTransactionReceipt();s.args.success||await this.extractFailureReason(i),this.stop(),this.resolve(i),this.resolved=!0}async extractFailureReason(t){t.status=0;const e=await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash,this.sender),t.blockHash);if(e[0]){let a=e[0].args.revertReason;a.startsWith("0x08c379a0")&&(a=P.decode(["string"],"0x"+a.substring(10)).toString()),this.reject(new Error(`UserOp failed with reason: ${a}`))}}}class ut extends X{constructor(t,e,a,s,i){super(),tt(this,"provider",a),this.config=t,this.originalSigner=e,this.erc4337provider=a,this.httpRpcClient=s,this.smartAccountAPI=i,this.approving=!1}async sendTransaction(t,e){var u;if(!this.approving){this.approving=!0;const d=await this.smartAccountAPI.createApproveTx();d&&await(await this.sendTransaction(d)).wait(),this.approving=!1}const a=await m(t);await this.verifyAllNecessaryFields(a);const s=E(),i=await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient,{target:a.to||"",data:((u=a.data)==null?void 0:u.toString())||"0x",value:a.value,gasLimit:a.gasLimit,nonce:s,maxFeePerGas:a.maxFeePerGas,maxPriorityFeePerGas:a.maxPriorityFeePerGas},e),r=await this.smartAccountAPI.signUserOp(i),c=await this.erc4337provider.constructUserOpTransactionResponse(r);try{await this.httpRpcClient.sendUserOpToBundler(r)}catch(d){throw this.unwrapError(d)}return c}unwrapError(t){var e,a;try{let s="Unknown Error";if(t.error)s=`The bundler has failed to include UserOperation in a batch: ${t.error}`;else if(t.body&&typeof t.body=="string"){const r=JSON.parse(t.body),c=t.status||"UNKNOWN",u=(r==null?void 0:r.code)||"UNKNOWN";let d=((e=r==null?void 0:r.error)==null?void 0:e.message)||((a=r==null?void 0:r.error)==null?void 0:a.data)||(r==null?void 0:r.error)||t.reason;if(d!=null&&d.includes("FailedOp")){let f="";const n=d.match(/FailedOp\((.*)\)/);if(n){const p=n[1].split(",");f=`(paymaster address: ${p[1]})`,d=p[2]}s=`The bundler has failed to include UserOperation in a batch: ${d} ${f}`}else s=`RPC error: ${d}
Status: ${c}
Code: ${u}`}const i=new Error(s);return i.stack=t.stack,i}catch{}return t}async verifyAllNecessaryFields(t){if(!t.to)throw new Error("Missing call target");if(!t.data&&!t.value)throw new Error("Missing call data or value")}connect(t){throw new Error("changing providers is not supported")}async getAddress(){return this.address||(this.address=await this.erc4337provider.getSenderAccountAddress()),this.address}async signMessage(t){await this.smartAccountAPI.checkAccountPhantom()&&(console.log("Account contract not deployed yet. Deploying account before signing message"),await(await this.sendTransaction({to:await this.getAddress(),data:"0x"})).wait());const[a,s]=await Promise.all([this.getChainId(),this.getAddress()]),i=et(t);let r,c;const u=at(a,this.config.clientId),d={};if(T(u)){const n=typeof globalThis<"u"&&"APP_BUNDLE_ID"in globalThis?globalThis.APP_BUNDLE_ID:void 0;this.config.secretKey?d["x-secret-key"]=this.config.secretKey:this.config.clientId&&(d["x-client-id"]=this.config.clientId,n&&(d["x-bundle-id"]=n)),typeof globalThis<"u"&&"TW_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_AUTH_TOKEN=="string"&&(d.authorization=`Bearer ${globalThis.TW_AUTH_TOKEN}`),typeof globalThis<"u"&&"TW_CLI_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_CLI_AUTH_TOKEN=="string"&&(d.authorization=`Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`,d["x-authorize-wallet"]="true"),b(d)}try{const n=new S({url:u,headers:d},a);await new N(s,["function getMessageHash(bytes32 _hash) public view returns (bytes32)"],n).getMessageHash(i),r=!0}catch{r=!1}if(r?c=(await st(this,{name:"Account",version:"1",chainId:a,verifyingContract:s},{AccountMessage:[{name:"message",type:"bytes"}]},{message:P.encode(["bytes32"],[i])})).signature:c=await this.originalSigner.signMessage(t),await rt(t,c,s,a,this.config.clientId,this.config.secretKey))return c;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")}async signTransaction(t,e){var u;const a=await m(t);await this.verifyAllNecessaryFields(a);const s=E(),i=await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient,{target:a.to||"",data:((u=a.data)==null?void 0:u.toString())||"0x",value:a.value,gasLimit:a.gasLimit,nonce:s},e),r=await this.smartAccountAPI.signUserOp(i);return JSON.stringify(await v(r))}}class gt extends j{constructor(t,e,a,s,i,r,c){super({name:"ERC-4337 Custom Network",chainId:t}),this.chainId=t,this.config=e,this.originalSigner=a,this.originalProvider=s,this.httpRpcClient=i,this.entryPoint=r,this.smartAccountAPI=c,this.signer=new ut(e,a,this,i,c)}getSigner(){return this.signer}async perform(t,e){if(t==="sendTransaction"||t==="getTransactionReceipt")throw new Error("Should not get here. Investigate.");return t==="estimateGas"?l.from(5e5):await this.originalProvider.perform(t,e)}async getTransaction(t){return await super.getTransaction(t)}async getTransactionReceipt(t){const e=await t,a=await this.getSenderAccountAddress();return await new Promise((s,i)=>{new _(s,i,this.entryPoint,a,e).start()})}async getSenderAccountAddress(){return await this.smartAccountAPI.getAccountAddress()}async waitForTransaction(t,e,a){const s=await this.getSenderAccountAddress();return await new Promise((i,r)=>{new _(i,r,this.entryPoint,s,t,void 0,a).start()})}async constructUserOpTransactionResponse(t){const e=await m(t),a=await this.smartAccountAPI.getUserOpHash(e);return{hash:a,confirmations:0,from:e.sender,nonce:0,gasLimit:l.from(e.callGasLimit),value:l.from(0),data:F(e.callData),chainId:this.chainId,wait:async s=>{const i=await this.smartAccountAPI.getUserOpReceipt(this.httpRpcClient,a);return e.initCode.length!==0&&await this.smartAccountAPI.checkAccountPhantom(),i}}}async detectNetwork(){return this.originalProvider.detectNetwork()}}function pt(o,t,e,a){const s=L.EntryPoint__factory.connect(o.entryPointAddress,e),i=new dt(o.bundlerUrl,o.entryPointAddress,a,o.clientId,o.secretKey);return new gt(a,o,o.localSigner,e,i,s,t)}const ft="0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";class wt{constructor(t){R(this,"isPhantom",!0),this.provider=t.provider,this.entryPointAddress=t.entryPointAddress,this.accountAddress=t.accountAddress,this.paymasterAPI=t.paymasterAPI,this.gasless=t.gasless,this.erc20PaymasterAddress=t.erc20PaymasterAddress,this.erc20TokenAddress=t.erc20TokenAddress,this.entryPointView=L.EntryPoint__factory.connect(t.entryPointAddress,t.provider).connect(I)}async checkAccountPhantom(){return this.isPhantom?((await this.provider.getCode(this.getAccountAddress())).length>2&&(this.isPhantom=!1),this.isPhantom):this.isPhantom}async getInitCode(){return await this.checkAccountPhantom()?await this.getAccountInitCode():"0x"}async getVerificationGasLimit(){return 1e5}async getUserOpHash(t){const e=await this.provider.getNetwork().then(a=>a.chainId);return nt(t,this.entryPointAddress,e)}async getAccountAddress(){return this.senderAddress||(this.accountAddress?this.senderAddress=this.accountAddress:this.senderAddress=await this.getCounterFactualAddress()),this.senderAddress}async estimateCreationGas(t){if(!t||t==="0x")return 0;const e=t.substring(0,42),a="0x"+t.substring(42);return await this.provider.estimateGas({to:e,data:a})}async createUnsignedUserOp(t,e,a){let{maxFeePerGas:s,maxPriorityFeePerGas:i}=e;if(T(t.bundlerUrl)){const h=await t.getUserOperationGasPrice();s=l.from(h.maxFeePerGas),i=l.from(h.maxPriorityFeePerGas)}else if(!s||!i){const h=await Y(this.provider);if(i||(i=h.maxPriorityFeePerGas??void 0),!s){s=h.maxFeePerGas??void 0;const w=(await this.provider.getNetwork()).chainId;(w===q.chainId||w===Z.chainId||w===Q.chainId)&&(i=s)}}if(!s||!i)throw new Error("maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely");const[r,c]=await Promise.all([this.getAccountAddress(),e.nonce?Promise.resolve(e.nonce):this.getNonce()]),u=await this.getInitCode(),d=mt(e.value)??l.from(0),f=a!=null&&a.batchData?e.data:await this.prepareExecute(e.target,d,e.data).then(async h=>(e.gasLimit||await this.provider.estimateGas({from:r,to:e.target,data:e.data,value:d}),h.encode())),n={sender:r,nonce:c,initCode:u,callData:f,maxFeePerGas:s,maxPriorityFeePerGas:i,callGasLimit:l.from(1e6),verificationGasLimit:l.from(1e6),preVerificationGas:l.from(1e6),paymasterAndData:"0x",signature:ft},p=(a==null?void 0:a.gasless)!==void 0?a.gasless:this.gasless;if(this.erc20PaymasterAddress&&this.erc20TokenAddress&&await this.isAccountApproved()){n.paymasterAndData=this.erc20PaymasterAddress;let h;try{h=await t.estimateUserOpGas(n)}catch(g){throw this.unwrapBundlerError(g)}n.callGasLimit=h.callGasLimit,n.verificationGasLimit=h.verificationGasLimit,n.preVerificationGas=h.preVerificationGas}else if(p){const h=await this.paymasterAPI.getPaymasterAndData(n),g=h.paymasterAndData;if(g&&g!=="0x"&&(n.paymasterAndData=g),h.callGasLimit&&h.verificationGasLimit&&h.preVerificationGas)n.callGasLimit=l.from(h.callGasLimit),n.verificationGasLimit=l.from(h.verificationGasLimit),n.preVerificationGas=l.from(h.preVerificationGas);else{let w;try{w=await t.estimateUserOpGas(n)}catch(y){throw this.unwrapBundlerError(y)}if(n.callGasLimit=w.callGasLimit,n.verificationGasLimit=w.verificationGasLimit,n.preVerificationGas=w.preVerificationGas,g&&g!=="0x"){const y=await this.paymasterAPI.getPaymasterAndData(n);y.paymasterAndData&&y.paymasterAndData!=="0x"&&(n.paymasterAndData=y.paymasterAndData)}}}else{let h;try{h=await t.estimateUserOpGas(n)}catch(g){throw this.unwrapBundlerError(g)}n.callGasLimit=h.callGasLimit,n.verificationGasLimit=h.verificationGasLimit,n.preVerificationGas=h.preVerificationGas}return{...n,signature:""}}async signUserOp(t){const e=await this.getUserOpHash(t),a=await this.signUserOpHash(e);return{...t,signature:a}}async getUserOpReceipt(t,e){let a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:12e4,s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:1e3;const i=Date.now()+a;for(;Date.now()<i;){const r=await t.getUserOperationReceipt(e);if(r)return await this.provider.waitForTransaction(r.receipt.transactionHash);await new Promise(c=>setTimeout(c,s))}throw new Error("Timeout waiting for userOp to be mined")}unwrapBundlerError(t){var a;const e=((a=t==null?void 0:t.error)==null?void 0:a.message)||t.error||t.message||t;return new Error(e)}}function mt(o){return!o||o===""?null:l.from(o.toString())}class yt extends wt{constructor(t,e){super({...t,provider:e}),this.params=t,this.sdk=C.fromPrivateKey(U,t.chain,{clientId:t.clientId,secretKey:t.secretKey,supportedChains:typeof t.chain=="object"?[t.chain]:void 0})}async getChainId(){return await this.provider.getNetwork().then(t=>t.chainId)}async getAccountContract(){var t;return this.accountContract||((t=this.params.accountInfo)!=null&&t.abi?this.accountContract=await this.sdk.getContract(await this.getAccountAddress(),this.params.accountInfo.abi):this.accountContract=await this.sdk.getContract(await this.getAccountAddress(),D)),this.accountContract}async getAccountInitCode(){const t=await this.getFactoryContract(),e=await this.params.localSigner.getAddress(),a=await this.params.factoryInfo.createAccount(t,e);return V([t.getAddress(),a.encode()])}async getFactoryContract(){var t;return this.factoryContract?this.factoryContract:((t=this.params.factoryInfo)!=null&&t.abi?this.factoryContract=await this.sdk.getContract(this.params.factoryAddress,this.params.factoryInfo.abi):this.factoryContract=await this.sdk.getContract(this.params.factoryAddress),this.factoryContract)}async getCounterFactualAddress(){if(this.params.accountAddress)return this.params.accountAddress;const t=await this.getFactoryContract(),e=await this.params.localSigner.getAddress();return this.params.factoryInfo.getAccountAddress(t,e)}async getNonce(){if(await this.checkAccountPhantom())return l.from(0);const t=await this.getAccountContract();return this.params.accountInfo.getNonce(t)}async prepareExecute(t,e,a){const s=await this.getAccountContract();return this.params.accountInfo.execute(s,t,e,a)}async prepareExecuteBatch(t,e,a){return(await this.getAccountContract()).prepare("executeBatch",[t,e,a])}async signUserOpHash(t){return await this.params.localSigner.signMessage($(t))}async isAcountDeployed(){return!await this.checkAccountPhantom()}async isAccountApproved(){if(!this.params.erc20PaymasterAddress||!this.params.erc20TokenAddress)return!0;const t=await this.getCounterFactualAddress(),e=(await M(()=>import("./index-5efc63cb.js").then(i=>i.eG),["assets/index-5efc63cb.js","assets/index-36f85667.css"])).default;return(await(await this.sdk.getContract(this.params.erc20TokenAddress,e)).call("allowance",[t,this.params.erc20PaymasterAddress])).gte(l.from(2).pow(96).sub(1))}async createApproveTx(){if(await this.isAccountApproved())return;const t=l.from(2).pow(96).sub(1),e=new z(U,this.provider),a=new N(this.params.erc20TokenAddress,["function approve(address spender, uint256 amount) public returns (bool)"],e);return{to:this.params.erc20TokenAddress,from:await this.getAccountAddress(),value:0,data:a.interface.encodeFunctionData("approve",[this.params.erc20PaymasterAddress,t])}}}class Pt extends k{constructor(t){super(),this.config=t}async initialize(t){var f,n,p,x,h,g;const e=this.config,a=B(e.chain,{clientId:e.clientId,secretKey:e.secretKey});this.chainId=(await a.getNetwork()).chainId;const s=this.config.bundlerUrl||`https://${this.chainId}.bundler.thirdweb.com`,i=this.config.paymasterUrl||`https://${this.chainId}.bundler.thirdweb.com`,r=e.entryPointAddress||H,c=await t.personalWallet.getSigner(),u={chain:e.chain,localSigner:c,entryPointAddress:r,bundlerUrl:s,paymasterAPI:this.config.paymasterAPI?this.config.paymasterAPI:lt(i,r,this.config.clientId,this.config.secretKey),gasless:e.gasless,factoryAddress:e.factoryAddress,accountAddress:t.accountAddress,factoryInfo:{createAccount:((f=e.factoryInfo)==null?void 0:f.createAccount)||this.defaultFactoryInfo().createAccount,getAccountAddress:((n=e.factoryInfo)==null?void 0:n.getAccountAddress)||this.defaultFactoryInfo().getAccountAddress,abi:(p=e.factoryInfo)==null?void 0:p.abi},accountInfo:{execute:((x=e.accountInfo)==null?void 0:x.execute)||this.defaultAccountInfo().execute,getNonce:((h=e.accountInfo)==null?void 0:h.getNonce)||this.defaultAccountInfo().getNonce,abi:(g=e.accountInfo)==null?void 0:g.abi},clientId:e.clientId,secretKey:e.secretKey,erc20PaymasterAddress:e.erc20PaymasterAddress,erc20TokenAddress:e.erc20TokenAddress};this.personalWallet=t.personalWallet;const d=new yt(u,a);this.aaProvider=pt(u,d,a,this.chainId),this.accountApi=d}async connect(t){return await this.initialize(t),await this.getAddress()}getProvider(){if(!this.aaProvider)throw new Error("Personal wallet not connected");return Promise.resolve(this.aaProvider)}async getSigner(){if(!this.aaProvider)throw new Error("Personal wallet not connected");return Promise.resolve(this.aaProvider.getSigner())}async getAddress(){return(await this.getSigner()).getAddress()}async isConnected(){try{return!!await this.getAddress()}catch{return!1}}async disconnect(){this.personalWallet=void 0,this.aaProvider=void 0}async switchChain(t){if((await(await this.getProvider()).getNetwork()).chainId!==t)throw new Error("Not supported.")}setupListeners(){return Promise.resolve()}updateChains(t){}async hasPermissionToExecute(t){var r;const e=await this.getAccountContract(),s=await(await this.getSigner()).getAddress(),i=(r=(await e.account.getAllSigners()).filter(c=>O(c.signer)===O(s))[0])==null?void 0:r.permissions;return i?i.approvedCallTargets.includes(t.getTarget()):!1}async send(t,e){return(await this.getSigner()).sendTransaction({to:t.getTarget(),data:t.encode(),value:await t.getValue()},e)}async execute(t,e){return{receipt:await(await this.send(t,e)).wait()}}async sendBatch(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await this.getSigner(),{tx:s,batchData:i}=await this.prepareBatchTx(t);return await a.sendTransaction({to:await a.getAddress(),data:s.encode(),value:0},{...e,batchData:i})}async executeBatch(t,e){return{receipt:await(await this.sendBatch(t,e)).wait()}}async sendRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");return(await this.getSigner()).sendTransaction(t,e)}async executeRaw(t,e){return{receipt:await(await this.sendRaw(t,e)).wait()}}async sendBatchRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await this.getSigner(),s=await this.prepareBatchRaw(t);return a.sendTransaction({to:await a.getAddress(),data:s.tx.encode(),value:0},{...e,batchData:s.batchData})}async executeBatchRaw(t,e){return{receipt:await(await this.sendBatchRaw(t,e)).wait()}}async estimate(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");return this.estimateTx({target:t.getTarget(),data:t.encode(),value:await t.getValue(),gasLimit:await t.getOverrides().gasLimit,maxFeePerGas:await t.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await t.getOverrides().maxPriorityFeePerGas,nonce:await t.getOverrides().nonce},e)}async estimateRaw(t,e){var s;if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await m(t);return this.estimateTx({target:a.to||I,data:((s=a.data)==null?void 0:s.toString())||"",value:a.value||l.from(0),gasLimit:a.gasLimit,maxFeePerGas:a.maxFeePerGas,maxPriorityFeePerGas:a.maxPriorityFeePerGas,nonce:a.nonce},e)}async estimateBatch(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const{tx:a,batchData:s}=await this.prepareBatchTx(t);return this.estimateTx({target:a.getTarget(),data:a.encode(),value:await a.getValue(),gasLimit:await a.getOverrides().gasLimit,maxFeePerGas:await a.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await a.getOverrides().maxPriorityFeePerGas,nonce:await a.getOverrides().nonce},{...e,batchData:s})}async estimateBatchRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const{tx:a,batchData:s}=await this.prepareBatchRaw(t);return this.estimateTx({target:a.getTarget(),data:a.encode(),value:await a.getValue(),gasLimit:await a.getOverrides().gasLimit,maxFeePerGas:await a.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await a.getOverrides().maxPriorityFeePerGas,nonce:await a.getOverrides().nonce},{...e,batchData:s})}async deploy(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await this.getSigner();return{receipt:await(await e.sendTransaction({to:await e.getAddress(),data:"0x"},{...t,batchData:{targets:[],data:[],values:[]}})).wait()}}async isDeployed(){if(!this.accountApi)throw new Error("Personal wallet not connected");return await this.accountApi.isAcountDeployed()}async deployIfNeeded(t){await this.isDeployed()||await this.deploy(t)}async grantPermissions(t,e){return(await this.getAccountContract()).account.grantPermissions(t,e)}async revokePermissions(t){return(await this.getAccountContract()).account.revokeAccess(t)}async addAdmin(t){return(await this.getAccountContract()).account.grantAdminPermissions(t)}async removeAdmin(t){return(await this.getAccountContract()).account.revokeAdminPermissions(t)}async getAllActiveSigners(){var e;if(await this.isDeployed())return(await this.getAccountContract()).account.getAllAdminsAndSigners();{const a=await((e=this.personalWallet)==null?void 0:e.getSigner());if(!a)throw new Error("Personal wallet not connected");return[{isAdmin:!0,signer:await a.getAddress(),permissions:{startDate:new Date(0),expirationDate:new Date(0),nativeTokenLimitPerTransaction:l.from(0),approvedCallTargets:[]}}]}}async getAccountContract(){var e;const t=C.fromSigner(await this.getSigner(),this.config.chain,{clientId:this.config.clientId,secretKey:this.config.secretKey});return(e=this.config.accountInfo)!=null&&e.abi?t.getContract(await this.getAddress(),this.config.accountInfo.abi):t.getContract(await this.getAddress(),D)}async getFactoryContract(){var e;const t=C.fromSigner(await this.getSigner(),this.config.chain,{clientId:this.config.clientId,secretKey:this.config.secretKey});return(e=this.config.factoryInfo)!=null&&e.abi?t.getContract(this.config.factoryAddress,this.config.factoryInfo.abi):t.getContract(this.config.factoryAddress)}defaultFactoryInfo(){return{createAccount:async(t,e)=>t.prepare("createAccount",[e,G("")]),getAccountAddress:async(t,e)=>await t.call("getAddress",[e,G("")])}}defaultAccountInfo(){return{execute:async(t,e,a,s)=>t.prepare("execute",[e,a,s]),getNonce:async t=>t.call("getNonce",[])}}async estimateTx(t,e){if(!this.accountApi||!this.aaProvider)throw new Error("Personal wallet not connected");let a=l.from(0);const[s,i]=await Promise.all([this.getProvider(),this.isDeployed()]);i||(a=await this.estimateDeploymentGasLimit());const[r,c]=await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient,t,e),K(s)]),u=await m(r),d=l.from(u.callGasLimit),f=d.mul(c),n=a.mul(c),p=n.add(f);return{ether:W(p),wei:p,details:{deployGasLimit:a,transactionGasLimit:d,gasPrice:c,transactionCost:f,deployCost:n,totalCost:p}}}async estimateDeploymentGasLimit(){if(!this.accountApi)throw new Error("Personal wallet not connected");const t=await this.accountApi.getInitCode(),[e,a]=await Promise.all([this.accountApi.estimateCreationGas(t),this.accountApi.getVerificationGasLimit()]);return l.from(a).add(e)}async prepareBatchRaw(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await Promise.all(t.map(r=>m(r))),a=e.map(r=>r.to||I),s=e.map(r=>r.data||"0x"),i=e.map(r=>r.value||l.from(0));return{tx:await this.accountApi.prepareExecuteBatch(a,i,s),batchData:{targets:a,data:s,values:i}}}async prepareBatchTx(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=t.map(i=>i.getTarget()),a=t.map(i=>i.encode()),s=await Promise.all(t.map(i=>i.getValue()));return{tx:await this.accountApi.prepareExecuteBatch(e,s,a),batchData:{targets:e,data:a,values:s}}}}export{Pt as SmartWalletConnector};
