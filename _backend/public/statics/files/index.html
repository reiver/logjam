<!DOCTYPE html>

<head>
  <title>SparkScience Broadcast Demo</title>
  <style>
    .node {
      cursor: pointer;
    }

    .node circle {
      fill: #fff;
      stroke: steelblue;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

    .some-class {
      border: solid 1px #999;
      border-radius: 5px;
      width: 49%;
    }

    body {
      padding: 30px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
</head>

<body>
  <input type="checkbox" onclick="toggleTurnUsage();" checked /> Use TURN <br />
  <button id="broadcast-btn" onclick="broadcast();">Broadcast</button><br />
  <button id="audience-btn" onclick="audience();">START</button><br />
  <!-- <button id="t" onclick="test();">TEST</button><br /> -->
  <div>
    <h3 style="text-align: center;">
      Status Report
    </h3>
    <button onclick="sendLog('I can see');">I can see</button>
    <button onclick="sendLog('I can`t see');">I can`t see</button>
    <button onclick="sendLog('Image is frozen');">Image is frozen</button>
    <button
      onclick="const status = prompt('What is the broadcast status?'); if (status) sendLog(status);">Other</button>
  </div>

  <h3 id="source-stream"></h3>
  <h4 id="user-name"></h4>
  <div style="display: flex;justify-content: space-between;">
    <div id="streams" class="some-class">
      Local: <br />
      <video id="send_video" autoplay playsinline muted style="width: 100%"></video><br />
    </div>
    <div id="graph-div" class="some-class"></div>
  </div>
  <script src="https://code.jquery.com/jquery-2.2.4.min.js"
    integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
  <!--  GRAPH -->
  <script>
    var lastTreeData;
    var margin = { top: 20, right: 120, bottom: 20, left: 120 },
      width = 960 - margin.right - margin.left,
      height = 500 - margin.top - margin.bottom;

    var i = 0,
      duration = 750,
      root;

    var tree = d3.layout.tree()
      .size([height, width]);

    var diagonal = d3.svg.diagonal()
      .projection(function (d) { return [d.y, d.x]; });

    var svg = d3.select("#graph-div").append("svg")
      .attr("width", width + margin.right + margin.left)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    function drawGraph(treeData) {

      lastTreeData = treeData;
      root = treeData[0];
      root.x0 = height / 2;
      root.y0 = 0;

      update(root);

      d3.select(self.frameElement).style("height", "500px");
    }
    function update(source) {

      // Compute the new tree layout.
      var nodes = tree.nodes(root).reverse(),
        links = tree.links(nodes);

      // Normalize for fixed-depth.
      nodes.forEach(function (d) { d.y = d.depth * 180; });

      // Update the nodes…
      var node = svg.selectAll("g.node")
        .data(nodes, function (d) { return d.id || (d.id = ++i); });

      // Enter any new nodes at the parent's previous position.
      var nodeEnter = node.enter().append("g")
        .attr("class", "node")
        .attr("transform", function (d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
        .on("click", click);

      nodeEnter.append("circle")
        .attr("r", 1e-6)
        .style("fill", function (d) { return d._children ? "lightsteelblue" : "#fff"; });

      nodeEnter.append("text")
        .attr("x", function (d) { return d.children || d._children ? -13 : 13; })
        .attr("dy", ".35em")
        .attr("text-anchor", function (d) { return d.children || d._children ? "end" : "start"; })
        .text(function (d) { return d.name; })
        .style("fill-opacity", 1e-6);

      // Transition nodes to their new position.
      var nodeUpdate = node.transition()
        .duration(duration)
        .attr("transform", function (d) { return "translate(" + d.y + "," + d.x + ")"; });

      nodeUpdate.select("circle")
        .attr("r", 10)
        .style("fill", function (d) { return d._children ? "lightsteelblue" : "#fff"; });

      nodeUpdate.select("text")
        .style("fill-opacity", 1);

      // Transition exiting nodes to the parent's new position.
      var nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", function (d) { return "translate(" + source.y + "," + source.x + ")"; })
        .remove();

      nodeExit.select("circle")
        .attr("r", 1e-6);

      nodeExit.select("text")
        .style("fill-opacity", 1e-6);

      // Update the links…
      var link = svg.selectAll("path.link")
        .data(links, function (d) { return d.target.id; });

      // Enter any new links at the parent's previous position.
      link.enter().insert("path", "g")
        .attr("class", "link")
        .attr("d", function (d) {
          var o = { x: source.x0, y: source.y0 };
          return diagonal({ source: o, target: o });
        });

      // Transition links to their new position.
      link.transition()
        .duration(duration)
        .attr("d", diagonal);

      // Transition exiting nodes to the parent's new position.
      link.exit().transition()
        .duration(duration)
        .attr("d", function (d) {
          var o = { x: source.x, y: source.y };
          return diagonal({ source: o, target: o });
        })
        .remove();

      // Stash the old positions for transition.
      nodes.forEach(function (d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }

    // Toggle children on click.
    function click(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
      update(d);
    }  
  </script>
  <!-- /GRAPH -->
  <script>
    let lastTree;
    let loggedIn = false;
    let hasStream = false;
    let myUsername,
      myName,
      targetName,
      myRole = "audiance",
      mode = 'audiance';
    let mediaConstraints = (window.constraints = {
      audio: true,
      video: true,
    });
    let localStream,
      shareScreenStream,
      sendStream,
      remoteStream = {},
      localScreenShare,
      myPeerConnection,
      broadcasterPeerConnection,
      myPeerConnections = [],
      iceCandidates = [],
      altIceCandidates = [],
      socket;
    try {
      myName = localStorage.getItem('logjam_myName');
    } catch (e) {
      console.log(e);
    }
    if (confirm(`Do you want to change ${myName} as your name?`)) {
      const newName = prompt('What is you name?');
      if (newName) {
        myName = newName;
        localStorage.setItem('logjam_myName', myName);
      }
    }
    if (myName === '' || !myName) {
      myName = makeid(20);
      try {
        localStorage.setItem('logjam_myName', myName);
      } catch (e) {
        console.log(e);
      }
    }
    function test() {
      socket.send(
        JSON.stringify({
          type: "stream",
          data: "true",
        })
      );
    }
    function refreshGraph() {
      socket.send(JSON.stringify({
        type: "tree",
        data: "",
        target: "1",
        name: ""
      }));
    }
    function makeid(length) {
      var result = '';
      var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      var charactersLength = characters.length;
      for (var i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    }
    var myPeerConnectionConfig = {
      iceServers: [
        {
          urls: ['stun:stun.l.google.com:19302']
        },
        {
          urls: ['stun:stun1.l.google.com:19302']
        },
        {

          urls: ['stun:stun2.l.google.com:19302']
        },
        {

          urls: ['stun:stun3.l.google.com:19302']
        },
        {

          urls: ['stun:stun4.l.google.com:19302']
        },
        {
          urls: ["turn:turn1.turn.group.video:3478"],
          username: "turnuser",
          credential: "dJ4kP05PHcKN8Ubu",
        },
        {
          urls: ["turn:turn2.turn.group.video:3478"],
          username: "turnuser",
          credential: "XzfVP8cpNEy17hws",
        },
        {
          urls: ["turns:turn1.turn.group.video:443"],
          username: "turnuser",
          credential: "dJ4kP05PHcKN8Ubu",
        },
        {
          urls: ["turns:turn2.turn.group.video:443"],
          username: "turnuser",
          credential: "XzfVP8cpNEy17hws",
        },
      ],
    };

    function createPeerConnection(targetUsername, view = "audience") {
      if (view === 'alt') {
        const tmpPeerConnection = new RTCPeerConnection(myPeerConnectionConfig);
        tmpPeerConnection.onicecandidate = function (event) {
          if (event.candidate) {
            console.log('Sending Candidate');
            socket.send(
              JSON.stringify({
                type: "alt-new-ice-candidate",
                target: targetUsername,
                candidate: event.candidate,
              })
            );
          }
        };
        tmpPeerConnection.ontrack = function (event) {
          console.log('[onTrack]', event);
        };
        tmpPeerConnection.onnegotiationneeded = function (event) {
          console.log('Creating Offer');
          tmpPeerConnection
            .createOffer()
            .then(function (offer) {
              return tmpPeerConnection.setLocalDescription(offer);
            })
            .then(function () {
              console.log('Sending Offer');
              socket.send(
                JSON.stringify({
                  name: myUsername,
                  target: targetUsername,
                  type: "alt-video-offer",
                  sdp: tmpPeerConnection.localDescription,
                })
              );
            })
            .catch(function (e) {
              console.log('[onnegotiationneeded]', e);
            });
        };
        tmpPeerConnection.onremovetrack = function (event) { };
        tmpPeerConnection.oniceconnectionstatechange = function (event) {
          if (tmpPeerConnection.iceConnectionState == 'disconnected') {
            console.log('Disconnected', tmpPeerConnection);
          }
        };
        tmpPeerConnection.onicegatheringstatechange = function (event) { };
        tmpPeerConnection.onsignalingstatechange = function (event) { };
        tmpPeerConnection.onicecandidateerror = (event) => {
        };
        return tmpPeerConnection;
      }
      if (myPeerConnections[targetUsername]) {
        return myPeerConnections[targetUsername];
      }
      myPeerConnection = new RTCPeerConnection(myPeerConnectionConfig);
      myPeerConnection.onicecandidate = function (event) {
        if (event.candidate) {
          socket.send(
            JSON.stringify({
              type: "new-ice-candidate",
              target: targetUsername,
              candidate: event.candidate,
            })
          );
        }
      };
      myPeerConnection.ontrack = function (event) {
        console.log('[onTrack stream length]', event.streams.length);
        event.streams.map((stream) => {
          console.log('stream id', stream.id);
          console.log('stream track length', stream.getTracks().length);
        });
        // setTimeout(() => {
        //   console.log('STRAEM TRUE');
        if (!hasStream) {
          hasStream = true;
          socket.send(
            JSON.stringify({
              type: "stream",
              data: "true",
            })
          );
        }
        // setTimeout(() => {
        //   socket.send(
        //     JSON.stringify({
        //       type: "stream",
        //       data: "true",
        //     })
        //   );
        //   console.log('after 10secs', socket);
        // }, 10000);
        // }, 5000);
        console.log('ontrack', event.streams[0]);
          console.log('Stream Count', event.streams);
          if ($("#local_video_" + event.streams[0].id).length === 0) {
            $("#streams").append(`<video id="local_video_${event.streams[0].id}" autoplay playsinline style="width: 100%"></video><br />`);
            document.getElementById("local_video_" + event.streams[0].id).srcObject = event.streams[0];
            document.getElementById("local_video_" + event.streams[0].id).play();
            remoteStream[event.streams[0].id] = event.streams[0];
            sendToAll(event.streams[0]);
          }
          // if (localStream && !shareScreenStream && localStream.id !== event.streams[0].id) {
          //   shareScreenStream = event.streams[0];
          //   document.getElementById("share_screen").srcObject =
          //     event.streams[0];
          // }
          // else if (!localStream) {
          //   document.getElementById("local_video").srcObject =
          //     event.streams[0];
          //   localStream = event.streams[0];
          //   localStream.onactive = (inp) => {
          //     console.log(`[localStream] onactive`, {inp});
          //   };
          //   localStream.oninactive = (inp) => {
          //     console.log(`[localStream] oninactive`, {inp});
          //   };
          //   localStream.onaddtrack = (inp) => {
          //     console.log(`[localStream] onaddtrack`, {inp});
          //   };
          //   localStream.onremovetrack = (inp) => {
          //     console.log(`[localStream] onremovetrack`, {inp});
          //   };
          //   $("#source-stream").text("Read " + targetName); //+ "[" + targetUsername + "]");
          //   socket.send(
          //     JSON.stringify({
          //       type: "stream",
          //       data: "true",
          //     })
          //   );
          socket.send(
            JSON.stringify({
              type: "log",
              data: "ontrack from " + targetName,
            })
          );
          // }
      };
      myPeerConnection.onnegotiationneeded = function (event) {
        myPeerConnection
          .createOffer()
          .then(function (offer) {
            return myPeerConnection.setLocalDescription(offer);
          })
          .then(function () {
            socket.send(
              JSON.stringify({
                name: myUsername,
                target: targetUsername,
                type: "video-offer",
                sdp: myPeerConnection.localDescription,
              })
            );
          })
          .catch(function (e) {
            socket.send(
              JSON.stringify({
                type: "log",
                data: "onnegotiationneeded audience error:" + JSON.stringify(e),
              })
            );
          });
      };
      myPeerConnection.onremovetrack = function (event) { };
      myPeerConnection.oniceconnectionstatechange = function (event) {
        socket.send(
          JSON.stringify({
            type: "log",
            data: "oniceconnectionstatechange :" + myPeerConnection.iceConnectionState,
          })
        );
        if (myPeerConnection.iceConnectionState == 'disconnected') {
          console.log('Disconnected', myPeerConnections);
          $("#streams").html("");
          hasStream = false;
          socket.close();
        }
      };
      myPeerConnection.onicegatheringstatechange = function (event) { };
      myPeerConnection.onsignalingstatechange = function (event) { };
      myPeerConnection.onicecandidateerror = (event) => {
        socket.send(
          JSON.stringify({
            type: "log",
            data: "onicecandidateerror :" + JSON.stringify(event),
          })
        );
      };
      myPeerConnections[targetUsername] = myPeerConnection;
      return myPeerConnection;
    }
    function sendToAll(aStream) {
      for(const targetUsername in myPeerConnections) {
        const myPeerConnection = myPeerConnections[targetUsername];
        aStream.getTracks().forEach((track) => {
          myPeerConnection.addTrack(track, aStream);
        });
      }
    }
    function connectUser(targetUsername, type = 'default') {
      if (type === 'alt') {
        broadcasterPeerConnection = createPeerConnection(targetUsername, type);

        if (sendStream) {
          sendStream.getTracks().forEach((track) => {
            broadcasterPeerConnection.addTrack(track, sendStream);
          });
        }

        return;
      }
      // console.log("Connect User", targetUsername);
      if (myPeerConnections[targetUsername]) {
        // console.log("Already Connected");
        return true;
      }
      let myPeerConnection = createPeerConnection(targetUsername);

      /*
      // console.log("localStream", localStream);
      if (localStream) {
        localStream.getTracks().forEach((track) => {
          // track["mmcomp"] = "VIDEO";
          myPeerConnection.addTrack(track, localStream);
        });
        // console.log("Added tracks to connection");
      }
      */
      for (streamId in remoteStream) {
        remoteStream[streamId].getTracks().forEach((track) => {
          // track["mmcomp"] = "VIDEO";
          myPeerConnection.addTrack(track, remoteStream[streamId]);
        });
      }
    }
    async function login() {
      let baseUrl = window.location.href.split("//")[1].split("/")[0];
      let protocol = "wss";
      if (window.location.href.split("//")[0] == "http:") {
        protocol = "ws";
      }
      socket = new WebSocket(`${protocol}://${baseUrl}/ws`);
      socket.onopen = function (event) {
        // console.log("[open] Connection established");
        // console.log("Sending start to server");
        socket.send(
          JSON.stringify({
            type: "start",
            data: myName,
          })
        );
      };

      socket.onclose = function (event) {
        if (event.wasClean) {
          console.log(
            `[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`
          );
        } else {
          console.log(
            `[close] Connection died, , code=${event.code} reason=${event.reason}`
          );
        }
        // myUsername = "";
        myPeerConnections = [];
        broadcasterPeerConnection = null;
        myPeerConnection = null;
        hasStream = false;
        login();
      };

      socket.onerror = function (error) {
        // console.log(`[error] ${error.message}`);
      };

      socket.onmessage = async function (event) {
        // console.log(`[message] Data received from server: ${event.data}`);
        let msg;
        try {
          msg = JSON.parse(event.data);
        } catch (e) {
          return;
        }
        msg.data = (msg.Data && !msg.data) ? msg.Data : msg.data;
        msg.type = (msg.Type && !msg.type) ? msg.Type : msg.type;
        // if (msg.type !== 'tree')
        //   console.log("Message", msg);
        if (msg.type == "video-offer") {
          let targetUsername = msg.name;
          targetName = msg.username;
          var desc = new RTCSessionDescription(msg.sdp);
          let myPeerConnection = createPeerConnection(targetUsername);
          // await myPeerConnection.setLocalDescription({type: "rollback"});
          await myPeerConnection.setRemoteDescription(desc);

          var answer = await myPeerConnection.createAnswer();

          await myPeerConnection.setLocalDescription(answer);

          socket.send(
            JSON.stringify({
              name: myUsername,
              target: targetUsername,
              type: "video-answer",
              sdp: myPeerConnection.localDescription,
            })
          );
        } else if (msg.type == "alt-video-offer") {
          let targetUsername = msg.name;
          targetName = msg.username;
          var desc = new RTCSessionDescription(msg.sdp);
          let myPeerConnection = createPeerConnection(targetUsername, true);
          // await myPeerConnection.setLocalDescription({type: "rollback"});
          await myPeerConnection.setRemoteDescription(desc);

          var answer = await myPeerConnection.createAnswer();

          await myPeerConnection.setLocalDescription(answer);

          socket.send(
            JSON.stringify({
              name: myUsername,
              target: targetUsername,
              type: "alt-video-answer",
              sdp: myPeerConnection.localDescription,
            })
          );
        } else if (msg.type == "new-ice-candidate") {
          iceCandidates.push(new RTCIceCandidate(msg.candidate));
          if (myPeerConnection && myPeerConnection.remoteDescription) {
            var candidate = iceCandidates.pop();
            myPeerConnection.addIceCandidate(candidate).catch(function (e) {
              // console.log("new-ice-candidate error:", e, candidate);
            });
          }
        } else if (msg.type == "alt-new-ice-candidate") {
          altIceCandidates.push(new RTCIceCandidate(msg.candidate));
          if (broadcasterPeerConnection && broadcasterPeerConnection.remoteDescription) {
            var candidate = altIceCandidates.pop();
            broadcasterPeerConnection.addIceCandidate(candidate).catch(function (e) {
              console.log("new-ice-candidate error:", e, candidate);
            });
          }
        } else if (msg.type == "alt-video-answer") {
          var desc = new RTCSessionDescription(msg.sdp);
          broadcasterPeerConnection.setRemoteDescription(desc).catch((e) => {
            console.log("Error", e);
          });
        } else if (msg.type == "video-answer") {
          var desc = new RTCSessionDescription(msg.sdp);
          myPeerConnection.setRemoteDescription(desc).catch((e) => {
            console.log("Error", e);
          });
        } else if (msg.type == "start") {
          if (!msg.error) {
            loggedIn = true;
            myUsername = msg.data
            $("#user-name").text("You are " + myName);// + "[" + myUsername + "]");
            if ($("#audience-btn").prop("disabled")) {
              audience();
            } else if ($("#broadcast-btn").prop("disabled")) {
              broadcast();
            }
          } else {
            alert(msg.error);
          }
        } else if (msg.type == "role") {
          // console.log("Role Message");
          if (msg.data === "no:broadcast") {
            alert("You are not a broadcaster anymore!");
            socket.close();
          } else if (msg.data === "yes:broadcast") {
            // console.log("Load Stream local", localStream);
            document.getElementById("local_video").srcObject = localStream;
            $("#source-stream").text("Broadcasting");
          } else {
            if (msg.data === "no:audience") {
              // $("#audience-btn").prop("disabled", false);
              // $("#broadcast-btn").prop("disabled", false);
              // $("#source-stream").text("");
              // alert("No broadcast to connect!");
              setTimeout(() => {
                audience();
              }, 200);
            }
            // document.getElementById("local_video").srcObject = null;

          }
        } else if (msg.type == "add_audience") {
          // console.log("add_audience", msg.data);
          connectUser(msg.data);
        } else if (msg.type == "add_broadcast_audience") {
          // console.log("add_audience", msg.data);
          connectUser(msg.data);
        } else if (msg.type == "tree") {
          const treeData = JSON.parse(msg.data);
          if (lastTree && lastTree === msg.data) {
            return;
          }
          lastTree = msg.data;
          if (treeData && treeData.length > 0) {
            drawGraph(treeData);
          }
        } else if (msg.type == "alt-broadcast") {
          console.log({ msg });
          if (msg.data === 'no-broadcaster') {
            alert('No Broadcaster is available!');
            return;
          }
          document.getElementById("send_video").srcObject = sendStream;
          alert('Waiting for Broadcaster Approve');
          // console.log('Start connecting to broadcaster');
          // connectUser(msg.data, 'alt');
        } else if (msg.type == "alt-broadcast-approve") {
          console.log('Start connecting to broadcaster');
          connectUser(msg.data, 'alt');
        }
        else if (msg.type == "error") {
          console.log('Error', msg);
          $("#audience-btn").prop("disabled", false);
          alert(msg.data);
        }
      };
    }

    function broadcast() {
      navigator.mediaDevices
        .getUserMedia(mediaConstraints)
        .then((ls) => {
          sendStream = ls;
          // console.log("Local Stream", localStream);
          socket.send(
            JSON.stringify({
              type: "role",
              data: "alt-broadcast",
            })
          );
        })
        .catch((e) => {
          console.log("Local St error", e);
        });
    }
    function audience() {
      socket.send(
        JSON.stringify({
          type: "role",
          data: "audience",
        })
      );
      const turnStatus = myPeerConnectionConfig.iceServers.findIndex(s => s.urls[0].indexOf('turn:') === 0) >= 0;
      socket.send(
        JSON.stringify({
          type: "turn_status",
          data: turnStatus ? "on" : "off",
        })
      );
      $("#audience-btn").prop("disabled", true);
      $("#broadcast-btn").prop("disabled", false);
      // document.getElementById("local_video").srcObject = null;
    }
    function toggleTurnUsage() {
      /*
      const turnRecord = {
        url: "turn:45.149.77.155:3478",
        username: "admin",
        credential: "mmcomp",
      };
      */
      const turnRecord = [
        {
          urls: ["turn:turn1.turn.group.video:3478"],
          username: "turnuser",
          credential: "dJ4kP05PHcKN8Ubu",
        },
        {
          urls: ["turn:turn2.turn.group.video:3478"],
          username: "turnuser",
          credential: "XzfVP8cpNEy17hws",
        },
        {
          urls: ["turns:turn1.turn.group.video:443"],
          username: "turnuser",
          credential: "dJ4kP05PHcKN8Ubu",
        },
        {
          urls: ["turns:turn2.turn.group.video:443"],
          username: "turnuser",
          credential: "XzfVP8cpNEy17hws",
        },
      ];
      const turnStatus = myPeerConnectionConfig.iceServers.findIndex(s => s.urls[0].indexOf('turn') === 0) >= 0;
      if (turnStatus) {
        myPeerConnectionConfig.iceServers = myPeerConnectionConfig.iceServers.filter(s => s.urls[0].indexOf('turn') < 0);
      } else {
        myPeerConnectionConfig.iceServers.push(...turnRecord);
      }
      console.log(myPeerConnectionConfig);
    }
    function sendLog(log) {
      socket.send(
        JSON.stringify({
          type: "log",
          data: log,
        })
      );
    }
    window.addEventListener("beforeunload", function () {
      if (socket) socket.close();
    });
    var isWebRTCSupported = navigator.getUserMedia ||
      navigator.webkitGetUserMedia ||
      navigator.mozGetUserMedia ||
      navigator.msGetUserMedia ||
      window.RTCPeerConnection;

    if (window.navigator.userAgent.indexOf("Edge") === -1 && isWebRTCSupported) {
      login();
      setInterval(() => {
        refreshGraph();
      }, 2000);
    } else {
      alert('Unfortunetly your browser does not support this action!');
    }
  </script>
</body>

</html>